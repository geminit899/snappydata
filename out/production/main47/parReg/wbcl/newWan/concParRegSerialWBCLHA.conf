hydra.Prms-testRequirement = "Test Partitioned region with serial AsyncEventListener with a variety of operations with careful validation and concurrent execution";
hydra.Prms-testDescription = "This test executes operations on entries on a PartitionedRegion and validates for correctness. 
Randomly kill ${numVMsToStop} VMs at a time, then bring it back and verify the data. Configured with serial AsyncEventListener";

INCLUDE $JTESTS/hydraconfig/hydraparams1.inc;
INCLUDE $JTESTS/hydraconfig/topology_p2p_2.inc;
hydra.GemFirePrms-distributedSystem = ds;   // all members are in the same DS

INITTASK  taskClass   = util.StopStartVMs  taskMethod = StopStart_initTask;

INITTASK  taskClass   = util.PRObserver  taskMethod = initialize
          runMode = once
          threadGroups = wbcl, peer
          ;

// define the local region for the wbcl to maintain (based on events)
INITTASK  taskClass = parReg.wbcl.ParRegWBCLTest   taskMethod = HydraTask_HA_initializeNewWanWBCL
          hydra.ConfigPrms-asyncEventQueueConfig  = wbclQueue
          hydra.ConfigPrms-regionConfig = wbclRegion
          runMode = always
          threadGroups = wbcl 
          ;

INITTASK  taskClass = parReg.wbcl.ParRegWBCLTest   taskMethod = HydraTask_HA_initializeDatastoreNewWanWBCL
          hydra.ConfigPrms-regionConfig  = dataStoreRegion
          runMode = always
          threadGroups = wbcl
          ;

// define the client region
INITTASK  taskClass = parReg.wbcl.ParRegWBCLTest   taskMethod = HydraTask_HA_initializeDataStore
          hydra.ConfigPrms-regionConfig  = dataStoreRegion
          runMode = always
          threadGroups = peer
          ;

INITTASK  taskClass   =  parReg.wbcl.ParRegWBCLTest  taskMethod = HydraTask_waitForMyStartupRecovery
          threadGroups = peer
          ;
             
// maxThreads of 1 means only one thread will be running the HAController at a time
TASK         taskClass   = parReg.wbcl.ParRegWBCLTest  taskMethod = HydraTask_HAController
             hydra.ConfigPrms-asyncEventQueueConfig  = wbclQueue
             threadGroups = peer
             maxThreads = 1
             ;

TASK         taskClass   = parReg.wbcl.ParRegWBCLTest  taskMethod = HydraTask_HADoEntryOps
             threadGroups = peer
             ;

CLOSETASK taskClass   = parReg.ParRegUtil  taskMethod = HydraTask_rebalance
          threadGroups = wbcl, peer
          ;

CLOSETASK taskClass   = parReg.wbcl.ParRegWBCLTest  taskMethod = HydraTask_prepareForValidation
          threadGroups = peer
          ;

CLOSETASK taskClass   = parReg.wbcl.ParRegWBCLTest  taskMethod = HydraTask_validatePR
          threadGroups = wbcl
          ;

CLOSETASK taskClass   = parReg.wbcl.ParRegWBCLTest  taskMethod = HydraTask_verifyWBCLRegion
          hydra.ConfigPrms-regionConfig = wbclRegion
          threadGroups = wbcl
          ;
          
THREADGROUP wbcl
    totalThreads = fcn
                   ${wbclHosts} * ${wbclVMsPerHost} * ${wbclThreadsPerVM}
                   ncf 
    clientNames  = fcn "hydra.TestConfigFcns.generateNames
                        (\"wbcl\", ${wbclHosts}, true)"
                   ncf;
THREADGROUP peer 
    totalThreads = fcn
                   ${dataStoreHosts} * ${dataStoreVMsPerHost} * ${dataStoreThreadsPerVM}
                   ncf 
    clientNames  = fcn "hydra.TestConfigFcns.generateNames
                        (\"dataStore\", ${dataStoreHosts}, true)"
                   ncf;

hydra.GemFirePrms-stopSystemsAfterTest = true;
hydra.GemFirePrms-conserveSockets =  false;

// parReg.ParRegPrms-secondsToRun determines the running length rather than 
// totalTaskTimeSec because of the test's pausing scheme; without this the
// test could hang 
hydra.Prms-totalTaskTimeSec = 31536000;  
hydra.Prms-maxResultWaitSec = 1020;
hydra.Prms-serialExecution = false;
hydra.Prms-clientShutdownHook = parReg.ParRegUtil dumpAllPartitionedRegions;

// this is the granularity for pausing
util.TestHelperPrms-minTaskGranularitySec = 10;

INCLUDE $JTESTS/util/randomValues.inc;
util.RandomValuesPrms-objectType = byte[];
util.RandomValuesPrms-elementSize = 1000;
util.ValueHolderPrms-useExtraObject = true;

hydra.ConfigPrms-cacheConfig    = cache1;
hydra.CachePrms-names           = cache1;
hydra.CachePrms-searchTimeout   = 600;

//WBCL configuration
hydra.AsyncEventQueuePrms-names                 = wbclQueue;
hydra.AsyncEventQueuePrms-asyncEventListener    = parReg.wbcl.newWan.MySerialAsyncEventListener;
hydra.AsyncEventQueuePrms-batchSize             = 10;
hydra.AsyncEventQueuePrms-diskStoreName         = wbclDisk;
hydra.AsyncEventQueuePrms-maximumQueueMemory    = 110;
hydra.AsyncEventQueuePrms-parallel              = false; //enable serial mode
hydra.AsyncEventQueuePrms-persistent            = ONEOF true false FOENO;
hydra.DiskStorePrms-names                       = disk wbclDisk;

hydra.RegionPrms-names          = dataStoreRegion   wbclRegion  dupEventPRegion;
hydra.RegionPrms-regionName     = dataStoreRegion   wbclRegion  dupEventPRegion;
hydra.RegionPrms-dataPolicy     = partition         replicate   replicate;
hydra.RegionPrms-scope          = default           ack         ack;
hydra.RegionPrms-asyncEventQueueNames = wbclQueue,  none,       none;
hydra.RegionPrms-cacheListeners = util.SummaryLogListener, util.InvisibleSilenceListener, none;
hydra.RegionPrms-partitionName  = pr                none        none; 

hydra.PartitionPrms-names           = pr;
hydra.PartitionPrms-redundantCopies = ${redundantCopies};

// don't allow conflict between multiple writers
parReg.ParRegPrms-bridgeOrderingWorkaround = uniqueKeys;
util.CachePrms-useDeclarativeXmlFile = false;

// The following 3 parameters specify random operations.
// The test will try to hold the size of the region to regionSizeThreshold.
// If the region grows larger in size than regionSizeThreshold, then the
// operations will be chosen from thresholdOperations, otherwise the operations
// will be chosen from entryOperations
// rdiyewar -- invalidate not supported by WAN/WBCL
parReg.ParRegPrms-entryOperations = ONEOF add putAll getNew putIfAbsentAsCreate update get destroy remove replaceNoInval replaceOldNoInval FOENO;
parReg.ParRegPrms-upperThreshold = 500;
parReg.ParRegPrms-upperThresholdOperations = ONEOF destroy remove FOENO;
parReg.ParRegPrms-lowerThreshold = 10;
parReg.ParRegPrms-lowerThresholdOperations = ONEOF add putIfAbsentAsCreate FOENO;
parReg.ParRegPrms-numPutAllNewKeys = 1;
parReg.ParRegPrms-numPutAllExistingKeys = RANGE 1 5 EGNAR;

parReg.ParRegPrms-secondsToRun = 900; // this is the time for the whole run
parReg.ParRegPrms-numVMsToStop = ${numVMsToStop};
//parReg.ParRegPrms-stopVMsMatchStr = "dataStore";  // only stop dataStore vm
parReg.ParRegPrms-localMaxMemory = RANGE 1 10 EGNAR;
util.StopStartPrms-stopModes = ONEOF NICE_EXIT MEAN_KILL MEAN_EXIT NICE_KILL FOENO;
parReg.ParRegPrms-highAvailability = true;

memscale.MemScalePrms-offHeapVerifyTargetCount = fcn (${dataStoreHosts} * ${dataStoreVMsPerHost} * ${dataStoreThreadsPerVM}) ncf;

